#define _CRT_SECURE_NO_WARNINGS 1

// c语言类型：
//	1.内置类型。如：char 字符整型、short 短整型、int 整型、long 长整型、long long 更长的整型、float 单精度浮点型、double 双精度浮点型
//	2.自定义类型（构造类型）：自己创造的类型。

// 类型的意义：
//	1.使用这个类型开辟内存空间的大小（大小决定了使用范围）
//	2.如何看待内存空间的视角。

//#include <stdio.h>
//int main()
//{
//	int a = 10;    // 内存申请4字节
//	float b = 10.0; // 内存申请4字节
//	// 通过在内存中发现，整型a存放方式和浮点型b存放方式不一样。同样存放10，但类型不同在内存中存放方式就不同。
//	return 0;
//}


// 整型在内存中是以补码形式存放
// 整型家族：00
// 除了char、short、int、long、long long之外还包括，unsigned char,signed char,unsigned short这样等等
// signed表示有符号的数，整型的二进制位最高位表示符号，1表示负号，0表示正号。
// 而unsigned表示无符号的数，二进制最高位不表示符号，都是正数

// 浮点型家族：float、double

// 构造类型（自定义类型）：
//	1.数组类型
//	2.结构体类型。struct
//	3.枚举类型。enum
//	4.联合类型。union

// 指针类型：如，int* p、char* p、float* p、void* p等等

// 空类型：void表示空类型（无类型）。通常应用于函数的返回类型、函数的参数、指针类型。



//     整形在内存中的存储

// 计算机的整型数有三种表示方法：原码、反码、补码
//三种表示方法均有符号位和数值位两部分，符号位是最高位，用0表示正，用1表示负数
// 有符号数中正数和无符号数的原码，反码和补码都相同。只有负数的不同需要变换。
// 负数的原码，直接把数字转化成二进制数，最高位为符号位定为1，表示负数。然后符号位不变，其它位取反，得到反码。最后反码加一得到补码

// 整数在内存中都是以补码的形式储存。因为CPU中只能计算加法，使用补码就可以加法代替减法
	//1-1;  // CPU在计算1-1时，转换成1+（-1）
	// 1+（-1）;
	//00000000000000000000000000000001   1的补码
	//11111111111111111111111111111111    -1的补码
	//相加得1后面32个0，但只有32比特的大小，越界了，舍掉最高位1，结果等于0。计算正确

//int a = 20;
//00000000000000000000000000010100
//0x00000014
// 为什么在内存中数是倒着存？

//大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中。
//小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。
// 这两种是按字节序的低位高位来存储，是按一个字节位单位。一个地址单元对应一个字节
// 因为当前vs下面采用小端存储模式，低位放在低地址中，高位放在高地址中，所以看起来是倒着存。


// 设计一个程序判断当前机器的字节序，大端还是小端
//#include <stdio.h>
//int main()
//{
//	int a = 9;
//	char* p1 = (char*)&a;
//	// char* p2 = p1 + 3;
//	/*if (*p1 > *p2)
//	{
//		printf("小端存储模式\n");
//	}
//	else
//		printf("大端存储模式\n");*/
//	if (*p1 == 9)
//		printf("小端存储\n");
//	else
//		printf("大端存储\n");
//	return 0;
//}



//#include <stdio.h>
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d b=%d c=%d\n", a, b, c);
//	// 打印的结果是a=-1 b=-1 c=255
//	// char类型占8个比特位，存入-1的补码 11111111
//	// 打印整型。a和b都是有符号数，整型提升，补上符号位，结果为-1。
//	// c为无符号数，整型提升高位补上0，结果为255
//	return 0;
//}



//#include <stdio.h>
//int main()
//{
//	char a = -128;
//	// -128 的原码 10000000000000000000000010000000
//	//        反码 11111111111111111111111101111111
//	//        补码 11111111111111111111111110000000
//	// 但char类型只有1字节空间，在补码上截断1字节，存入a的内容是 10000000
//	// %u 的意思是打印十进制的无符号数（整型int）
//	// 因为打印整数，先发生整型提升，最高位看作符号位，补上符号位 11111111111111111111111110000000   因为char类型的a是有符号的
//	// 又因为打印无符号数，就把这个数看作无符号数，打印结果为 4294967168
//	printf("%u\n", a); // %u 的意思是打印十进制的无符号数（整型int）
//	return 0;
//}




// char,signed char,unsigned char 都占1个字节，8个比特位。也就有256种二进制序列
// char，signed char为有符号数，最高位表示符号。所能表示的范围：-128到127。 补码10000000直接判断为-128
// unsigned char 为无符号数，所能表示的范围为 0到255
// 同理，容易得到int、short、long等等，这些的范围

//#include <stdio.h>
//int main()
//{
//	char a = 128; 
//	//char a = -128;
//	printf("%u\n", a);  // a为128或者-128结果一样
//	return 0;
//}



//#include <stdio.h>
//#include <string.h>
//int main()
//{
	//int i = -20;
	////  -20的原码为   10000000000000000000000000010100
	////       反码为   11111111111111111111111111101011
	////       补码为   11111111111111111111111111101100
	//unsigned int j = 10;
	////    10的补码为  00000000000000000000000000001010

	////      i加j等于  11111111111111111111111111110110 
	////     转化成反码 11111111111111111111111111110101
	////     转化成原码 10000000000000000000000000001010
	////      结果为-10
	//printf("%d\n", i + j);   // 计算按照补码的形式进行运算，最后格式化称为有符号整数


	//unsigned int i;
	//for (i = 9; i >= 0; i--)  // 死循环，因为unsigned int i 为无符号数，永远大于等于0
	//{
	//	printf("%u\n", i);
	//}



	/*char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	printf("%d", strlen(a));*/
	// strlen求字符数组长度，找到'\0'终止。
	// char只能包括-128到127的范围，因此字符数组的第一个元素存-1开始，存到-128后，存127，然后存到0，而'\0'的ASCII码值就是0。
	// 故用strlen求得字符数组的长度为255。
//	return 0;
//}

//#include <stdio.h>
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)   //  死循环。因为无符号的字符整型的数，范围为0到255，永远不可能大于255。
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}

//  无符号数  特别容易造成死循环！！



