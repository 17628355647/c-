#define _CRT_SECURE_NO_WARNINGS 1

// 浮点数：3.14159 1E10     1E10表示1.0乘10的10次方。

// 浮点数家族包括：float、double、long double类型。浮点数表示的范围：float.h中定义
//#include <stdio.h>
//int main()
//{
//	double d = 1E10;  // 1E10 表示1.0乘10的10次方
//	printf("%lf", d);
//	return 0;
//}

//int main()
//{
//	int n = 9;
//	float* p = (float*)&n;
//	printf("n的值：%d\n", n);
//	printf("*p的值：%f\n", *p);
//	*p = 9.0;
//	printf("---------------------\n");
//	printf("n的值：%d\n", n);
//	printf("*p的值：%f\n", *p);
//	return 0;
//}
// 通过上面代码，我们知道浮点型和整型在内存中的存放形式不同。


#include <stdio.h>
// 浮点数在内存是如何存储的呢？
// 根据国际标准IEEE的754标准，任意一个二进制浮点数V可以表示成下面的形式：
//		(-1)^S * M * 2^E
//		(-1)^S表示符号位，当S=0，V为正数，当S=1，V为负数
//		M表示有效数字，大于等于1，小于2
//		2^E表示指数位
//比如存放一个9.0的浮点数，先转化成二进制数，1001.0。再写成二进制的科学计数法，1.001 * 2^3。易得(-1)^0 * 1.001 * 2^3。可知S=0，M=1.001，E=3
//  存放浮点数 0.5，先转化成二进制数0.1（0.5中5的权重是2的-1次方，也就是十分位上的5转换成二进制是0.1）。再写成科学计数法表示形式1.0 * 2^(-1)
//     也就是(-1)^0 * 1.0 * 2^(-1)
// 
// 所以浮点数在内存中只需要存储S、M和E就可以表示任意一个浮点数，
// IEEE 754规定：对于32位（也就是4字节）的浮点数（float），最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。
//               对于64位（也就是8字节）的浮点数（double），最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。
// 
// 因为M总是大于等于1，小于2。也就是M可以写成1.xxxxxx的形式，所以在保存M的时候只保留后面的小数部分。读取的时候，再把第一位1加上去，
//     这样做的目的，是节省1位有效数字。以32位浮点数为列，留给M的只有23位，而最前面的1总会占1位，
//		将其舍掉之后，后面的小数位就可以多占一位。使其精度提高。

// 至于指数E，情况比较复杂。E作为一个无符号整数意味着，E为8位的话，取值范围为0到255。如果E为11位的话，取值范围为0到2047。
// 但是科学计数法是可以有负数的，所以存入内存时E的真实值必须加上一个中间数，对于8位E，这个中间数为127，对于11位E，中间数为1023。
//  比如2^10 的E是10，保存为137（10+127 =137）的二进制序列。2^(-1)，E是-1，保存为126（-1+127=126）的二进制序列。
//  这样子就合理的保存了E为负的情况。在用E的时候只需减去127便可。

//int main()
//{
//	float f = 5.5;
//	//       十进制：5.5 
//	// 转化成二进制：101.1
//	// 写成科学计数法表示形式：(-1)^0 * 1.011 * 2^2
//	// S=0  E=2(存入内存要加上127，也就是129。129的二进制序列：10000001)      M=1.011（不存1，也就是在内存中只存小数位 011）
//	//存入内存： 0 10000001 01100000000000000000000
//	// 二进制位不方便观看，转化成16进制位。4个而二进制位为一个16进制位（因为1111转化成16进制为15）
//	// 0100 0000 1011 0000 0000 0000 0000 0000
//	// 也就是0x40b00000
//	return 0;
//}


//  指数E从内存中取出还可以分成三种情况：
//	1.E不全为全或不全为1。取出E时，减去127（或1023）得到真实值，再将有效数字M前填上1
//	2.E全为0。浮点数的指数E等于-127，2^(-127)是一个超级超级小的数。
//     所以特殊处理。浮点数的指数E等于1-127（1-1023）即E等于-126或-1022，为真实值。
//		有效数字M不再填1，而是还原为0.xxxx的小数。这样做是为了表示±0，以及接近0的很小的数字。
//	3.E全为1。意味着指数E为128，而2^128非常非常大。也特殊处理，不做讨论，表示±无穷大。



int main()
{
	int n = 9;
	// 00000000000000000000000000001001
	float* p = (float*)&n;
	// 0 00000000 00000000000000000001001
	// (-1)^0 * 0.00000000000000000001001 * 2^(-126)   非常小的数
	printf("n的值：%d\n", n);   // 打印9
	printf("*p的值：%f\n", *p); // 打印0.000000  因为精度为小数点后6位
	*p = 9.0;
	// 1001.0
	// (-1)^0 * 1.001 * 2^3
	// 0 10000010 00100000000000000000000
	printf("---------------------\n");
	printf("n的值：%d\n", n);  //打印整数， 把这个数看成补码01000001000100000000000000000000  打印1091567616
	printf("*p的值：%f\n", *p); // 打印浮点数，9.0
	return 0;
}